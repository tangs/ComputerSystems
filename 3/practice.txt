3.1:
%rax                                                        0x100
0x104                                                       0xAB
$0x108                                                      0x108
(%rax)                                                      0xFF
4(%rax)                                                     0xAB
9(%rax, %rdx)       (9+%rax+%rax*1)=(9+0x104+0x3)=(0x10C)   0x11
260(%rcx, %rdx)     (0x104+0x1+0x3)=(0x108)                 0x13
0xFC(, %rcx, 4)     (0xFC+0x1*4)=(0x100)                    0xFF
(%rax, %rdx, 4)     (0x100+0x3*4)=(0x10C)                   0x11

3.2:
movl
movw
movb
movb
movq
movw

0x0011223344556677
0xAA
0x00112233445566AA
0xFFFFFFFFFFFFFFAA
0x00000000000000AA

3.3:
movl
movq
不能memory--memory
没有sl
目标不能是Immediate
movq
movw

3.4:
rdi edi ei dil
rsi esi si sil
rax eax ax al
char                int             movsbl (%rdi),%eax  movsbl %eax,(%rsi)
char                unsigned        movsbl (%rdi),%eax  movl %eax,(%rsi)
unsigned char       long            movzbq (%rdi),%rax  movq %rax,(%rsi)
int                 char            movb (%rdi),%al     movb %al,(%rsi)
unsigned            unsigned char   movb (%rdi),%al     movb %al,(%rsi)
char                short           movsbw (%rdi),%ax   movw %ax,(%rsi) 

3.5:
void decode1(long *xp, long *yp, long *zp) {
    long a = *xp;
    long b = *yp;
    long c = *zp;
    *yp = a;
    *zp = b;
    *xp = c;
}

3.6:
6 + x
x + y
x + 4y
7 + 9x
10 + 4y
9 + x + 2y

3.7:
5x + 2y + 8z

3.8:
0x100   0x100
0x108   0xA8
0x118   0x110
0x110   0x14
%rcx    0x0
%rax    0xFD

3.9:
salq $4, %rax
sarq %cl, %rax

3.10:
y | x
t1 >> 3
~t2
z - t3

3.11:
A.将%rdx值置为0
B.movq $0, %rdx
C.3个字节和7个字节

3.12:
movq	%rdx, %r8
movq	%rdi, %rax
xor		%rdx, %rdx
divq	%rsi
movq	%rax, (%r8)
movq	%rdx, (%rcx)

3.13:
A   <   int
B   >=  short
C   <=  unsigned char  
D   !=  long or unsigned long or void*

3.14:
A   >=  long 
B   ==  short or unsigned short
C   >   unsigned char
D   !=  int or unsigned int

3.15:
A   4003fe
B   400431-0x0C=400425
C   400543  400545
D   4005ed-8d=400560

3.16:
    void cond(long a, long *p)
    a in %rdi, p in %rsi
    cond:
    testq   %rsi, %rsi          // test q
    je      .L1                 // if 0 goto .L1
    compq   %rdi, (%rsi)        // cmp *p a
    jge     .L1                 // if >= goto .L1
    movq    %rid, (%rsi)        // *q = a
    .L1:
    req: ret                    // return

A.
    void cond(long a, long *p) {
        if (p == 0)
            goto ret;
        if (*p >= a)
            goto ret;
        *p = a;
    ret:
        return;
    }
B.因为C语言中的一个if语句中包含两个条件判断.

3.17:
A.
    long absdiff_se(long x, long y) {
        long result;
        if (x < y)
            goto x_l_y;
        ge_cnt++;
        result = x - y;
        return result;
    x_l_y:
        lt_cnt++;
        result = y - x;
        return result;
    }
B.没想出

3.18:
    test:
        leaq    (%rdi, %rsi), %rax      // val = x + y
        addq    %rdx, %rax              // val += z
        cmpq    $-3, %rdi               // cmp x -3
        jge     .L2                     // if >= goto .L2
        cmpq    %rdx, %rsi              // cmp y z
        jge     .L3                     // if >= goto .L3
        movq    %rdi, %rax              // val = x
        imulq   %rsi, %rax              // val *= y
    .L3:
        movq    %rsi, %rax              // val = y
        imulq   %rdx, %rax              // val *= z
    .L2:
        cmpq    $2, %rdi                // cmp x 2
        jle     .L4                     // if <= goto .L4
        movq    %rdi, %rax              // val = x
        imulq   %rdx, %rax              // val *= z
    .L4:
        req; ret                        // return

    long test(long x, long y, long z) {
        long val = x + y + z;
        if (x < -3) {
            if (y < z)
                val = x * y;
            else
                val = y * z;
        } else if (x > 2)
            val = x * z;
        return val;
    }

3.19:
    Tok = 16 
    Tran =  31 
    A.
        Tmp = 2 * (Tran - Tok) = 30
    B.
        Tran = (Tok + Terr) / 2
        Terr = 2 * Tran - Tok = 2 * 31 - 16 = 46
        Terr = Tok + Tmp = 16 + 30 = 46

3.20:
    ret = x + 7
    x & x
    if (x >= 0)  ret = x
    ret >>= 3

    if (x >= 0)
        ret x >> 3;
    else
        ret (x + 7) >> 3;

    A. OP / 

3.21:
    long test(long x, long y);
    x in %rdi, y in %rsi
  test:
    leaq    0(, %rdi, 8), %rax          // ret = 8 * x
    testq   %rsi, %rsi                  // test y
    jle     .L2                         // if <= jump .L2
    movq    %rsi, %rax                  // ret = y
    subq    %rdi, %rax                  // ret = ret - x
    movq    %rdi, %rdx                  // %rdx = x
    andq    %rsi, %rdx                  // %rdx = rdx & y
    cmpq    %rsi, %rdi                  // cmp x - y
    cmovge  %rdx, %rax                  // if >= ret = %rdx
    ret
  .L2:
    addq    %rsi, %rdi                  // x = x + y
    cmpq    $-2, %rsi                   // cmp y - (-2)
    cmovle  %rdi, %rax                  // if <= ret = x
    ret

    long val = 8 * x;
    if (y > 0) {
        if (x >= y)
            ret = x & y;
        else
            ret = y - x;
    } else if (y <= -2)
        ret = x + y;

3.23:
    C.
        ret = x
        %rcx = x
        %rcx *= x
        %rdx = 2 * x
    .L2:
        ret += %rcx + 1
        %rdx = %rdx - 1
        if (%rdx > 0)
            goto .L2
    A.
        x: %rdi
        y: %rcx
        n: %rdx
    
3.24:
    long loop_while(long a, long b)
    {
        long result = 1;
        while (a < b) {
            result = result * (a + b);
            a = a + 1;
        }
        return reslut;
    }
    
3.25:
    long loop_while2(long a, long b)
    {
        long result = b;
        while (b > 0) {
            reslut *= a;
            b -= a;
        }
        return result;
    }

3.26:
    A. jump to middle
    B.
    long fun_a(unsigned long x) {
        long val = 0;
        while (x != 0) {
            val ^= x;
            x >>= 1;
        }
        return 1 & val;
    }
    C.计算x的二进制位为1的总数是否为奇数.

3.27:
while:
    long fact_for(long n) {
        long result = 1;
        long i = 2;
        while (i <= n) {
            result *= i;
        }
        return result;
    }
guarded-do;
    long fact_for(long n) {
        long result = 1;
        long i = 2;
        if (i > n)
            goto done;
    loop:
        result *= i;
        i += 1; 
        if (i <= n)
            goto loop;
    done:
        return result;
    }

3.28:
    A.
    for (i = 64; i != 0; --i) {
        long y = x & 1;
        val += val; // val <<= 1;
        val |= y;
        x >>= 1;
    }
    B.因为i的初始值保证了第一次条件判断结果肯定为真.
    C.按位翻转.

3.29:
    A.
    long sum = 0;
    long i;
    while (i < 10) {
        if (i & 1)
            continue;
        sum += i;
        i++;
    }
    死循环
    B.
    long sum = 0;
    long i;
    while (i < 10) {
        if (i & 1)
            goto .Update;
        sum += i;
    .Update:
        i++;
    }

3.30:
    A.
    .quad   .L9     // -1
    .quad   .L5     // 0
    .quad   .L6     // 1
    .quad   .L7     // 2
    .quad   .L2     // 
    .quad   .L7     // 4
    .quad   .L8     // 5
    .quad   .L2     // 
    .quad   .L5     // 7
    B.
        0   7
        2   4

3.31:
    void switcher(long a, long b, long c, long *dest) {
        long val;
        switch(a) {
        case 5:
            c = b ^ 15;
        case 0:
            val = 112 + c;
            break;
        case 2:
        case 7:
            val = (b + c) << 2;
            break;
        case 4:
            val = a;
            break;
        default:
            val = b;
        }
        *dest = val;
    }
